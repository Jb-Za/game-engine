// AssetScanner.ts - Service for discovering GLTF assets

export interface GLTFAssetInfo {
  name: string;
  path: string;
  thumbnailPath?: string;
  lastModified: Date;
  size: number;
  hasAnimation?: boolean;
  description?: string;
  category?: string;
}

// interface AssetConfig {
//   name: string;
//   file: string;
//   description: string;
//   category: string;
//   hasAnimation: boolean;
// }

export class AssetScanner {
  private static readonly ASSETS_PATH = '';
  private static readonly THUMBNAILS_PATH = '/thumbnails/';

  /**
   * Scan for GLTF assets in the assets directory
   * Uses configuration for known assets, with fallback to manual discovery
   */
  static async scanGLTFAssets(): Promise<GLTFAssetInfo[]> {
    try {
      const assets: GLTFAssetInfo[] = [];

      // Fetch all files from the assets directory and build entries for any .gltf/.glb
      const files = await this.getAllAssets();
      for (const file of files) {
        if (!file) continue;

        const lower = file.toLowerCase();
        // skip anything that isn't a GLTF/GLB
        if (!(lower.endsWith('.gltf') || lower.endsWith('.glb'))) continue;

        const assetPath = this.ASSETS_PATH + file;

        try {
          // Fetch the asset directly to confirm availability (per request).
          // Note: this downloads headers and connection; body is not read here.
          const response = await fetch(assetPath);
          if (!response.ok) {
            continue;
          }

          const size = parseInt(response.headers.get('content-length') || '0');
          const lastModHeader = response.headers.get('last-modified');
          const lastModified = lastModHeader ? new Date(lastModHeader) : new Date();

          const fileName = file.split('/').pop() || file;
          const name = fileName.replace(/\.[^/.]+$/, '');

          const thumbnailPath = this.THUMBNAILS_PATH + name + '.png';
          let hasThumbnail = false;
          try {
            const thumbResponse = await fetch(thumbnailPath, { method: 'HEAD' });
            hasThumbnail = thumbResponse.ok;
          } catch {
            hasThumbnail = false;
          }

          assets.push({
            name,
            path: assetPath,
            thumbnailPath: hasThumbnail ? thumbnailPath : undefined,
            lastModified,
            size,
          });
        } catch (error) {
          console.warn(`Could not check asset: ${file}`, error);
        }
      }

      console.log(`Found ${assets.length} GLTF assets`);
      return assets;
    } catch (error) {
      console.error('Error scanning GLTF assets:', error);
      return [];
    }
  }

  /**
   * Get the thumbnail path for a given asset
   */
  static getThumbnailPath(assetName: string): string {
    return this.THUMBNAILS_PATH + assetName + '.png';
  }

  /**
   * Check if a thumbnail exists for the given asset
   */
  static async thumbnailExists(assetName: string): Promise<boolean> {
    try {
      const response = await fetch(this.getThumbnailPath(assetName), { method: 'HEAD' });
      return response.ok;
    } catch {
      return false;
    }
  }

  static async getAllAssets(): Promise<string[]> {
    // Load manifest generated by build script at /config/gltf-assets.json
    const manifestPath = '/config/gltf-assets.json';
    try {
      const resp = await fetch(manifestPath);
      if (!resp.ok) {
        console.warn(`Manifest not found at ${manifestPath}: ${resp.status} ${resp.statusText}`);
        return [];
      }
      const data = await resp.json();
      if (Array.isArray(data)) {
        return data.filter(f => typeof f === 'string' && f.trim());
      }
      return [];
    } catch (err) {
      console.warn('Could not load GLTF assets manifest:', err);
      return [];
    }
  }
}
